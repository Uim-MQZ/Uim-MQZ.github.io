[{"title":"快速排序","url":"/2022/01/21/newpapername/","content":"## 快速排序\n\n## 1.举个例子\n   首先我们给出组数据：6 1 2 7 9 3 4 5 10 8\n   接下来，我们的目的是将他们**从小到大**排序；\n   \n   首先：我们设立一个**基准数**(也就是这组数据的第一个数，6)，接下来，我们需要把**比基准数6大**的数全部放到6的**右边**，**比基准数6小**的数全部放到6的**左边**（也就是将**基准数**放在中间某个位置使得基准数左边的数全部小于他，基准数右边的数全部大于他）\n   \n   那么我们该如何实现这个过程呢？\n   我们可以用**交换**的方法，我们从右边开始，寻找一个**比6小**的数，再从左边寻找一个**比6大**的数，然后**交换他们的位置**\n   这里我们需要用到两个小可爱：**i** 和 **j**；让他们分别从左右两端开始寻找符合要求的数\n   看下图\n|   ==6==   |   1   |   2   |   7   |   9   |   3   |   4   |   5   |   10   |   ==8==   |\n|----|----|----|----|----|----|----|----|----|----|\n|   ==**i**==  |      |      |      |      |      |    |      |    |   ==**j**==  |\n小可爱 **j** 开始移动（每次必须是从 j 开始！）\n|  ==6==   |   1   |   2   |   7   |   9   |   3   |   4   |  ==5==   |   10   |   8   |\n|----|----|----|----|----|----|----|----|----|----|\n|   ==**i**==  |      |      |      |      |      |    |    ==**j**==   |    |    |\n找到一个比6小的数了，然后就是 i 的工作了\n|   6   |   1   |   2   |  ==7==   |   9   |   3   |   4   |   ==5==   |   10   |   8   |\n|----|----|----|----|----|----|----|----|----|----|\n|     |      |      | ==**i**==    |      |      |    |    ==**j**==   |    |    |\n交换！\n|   6   |   1   |   2   |  ==5==   |   9   |   3   |   4   |   ==7==   |   10   |   8   |\n|----|----|----|----|----|----|----|----|----|----|\n|     |      |      | ==**i**==    |      |      |    |    ==**j**==   |    |    |\n我们发现 **i** 和 **j** 并没有相遇，那么我们继续，我们发现9>6,4<6,果断交换！\n|   6   |   1   |   2   |  5   |   ==4==   |   3   |   ==9==   |   7 |   10   |   8   |\n|----|----|----|----|----|----|----|----|----|----|\n|     |      |      |    | ==**i**==      |      |    ==**j**==  |     |    |    |\n接下来，我们的小可爱 **i** 和 **j** 终于见到了彼此，那么我们就将 3 和 **基准数6** 交换，这样我们就找到了属于 6 的那个专属位置 **k** ！\n|   ==3==   |   1   |   2   |  5   |   4   |   ==6==   |   9  |   7 |   10   |   8   |\n|----|----|----|----|----|----|----|----|----|----|\n|     |      |      |    |   |   ==**i j**==    |      |     |    |    |\n到此第一轮“探测”真正结束。现在**基准数6**已经归位，此时以**基准数6**为分界点，6左边的数都小于等于6，6右边的数都大于等于6。回顾一下刚才的过程，其实哨兵 **j** 的使命就是要找小于基准数的数，而哨兵 **i** 的使命就是要找大于基准数的数，直到 **i** 和 **j** 碰头为止。\n\n现在我们将第一轮“探测\"结束后的序列，就需要用到**二分**的思想。以6为**分界点**拆分成两个序列，左边的序列是“3 1 2 5 4”，右边的序列是“9 7 10 8”。接下来还需要分别处理这两个序列。因为6左边和右边的序列目前都还是很混乱的。不过不要紧，我们已经掌握了方法，接下来只要模拟刚才的方法分别处理6左边和右边的序列即可。现在先来处理6左边的序列现吧。\n\n第一轮探测后，我们得到以下序列\n|   ==2==   |   1   |   ==3==   |  5   |   4   |\n|----|----|----|----|----|----|----|----|----|----|\n接下来我们又以 3 为分界点\n|   ==1==   |   ==2==   |   3   |  ==4==   |  ==5==   |\n|----|----|----|----|----|----|----|----|----|----|\t\n如此便将 6 左边的序列排好序，右边同样如此；\n由此我们可以发现，每一轮排序的过程，就是将**基准数**归位的过程，直到将每一位**基准数**归位，这个过程就结束了。\n\n接下来以《啊哈算法》里面的图示来展现：\n![666](https://img-blog.csdnimg.cn/c8d7255438c8415cb3828253eb1b0ce5.jpg?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5qmY6JC95Lqs5Z-O,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center)\n在最坏的情况下，可能是相邻的两个数进行了交换。因此快速排序的最差时间复杂度和\n冒泡排序是一样的，都是 O(N2)，它的平均时间复杂度为 O (NlogN)。其实快速排序是基于一种叫做“二分”的思想。\n## 2.代码实现\n下面是这个算法的代码实现\n\n```cpp\nvoid quicksort(int left,int right)\n{\n\tif(left>right)\n\t\treturn ;//判断是否错误 \n\tint i=left,j=right; \n\tint temp=a[left];//temp 用来存储基准数 \n\twhile(i!=j)//当i,j没有相遇时 \n\t{\n\t\twhile(a[j]>=temp&&i<j)//直到寻找到一个比基准数大的数 \n\t\t\tj--;\n\t\twhile(a[i]<=temp&&i<j)//直到寻找到一个比基准数大的数\n\t\t\ti++;\n\t\tif(i<j)//必须满足i<j \n\t\t\tswap(a[i],a[j]);//swap是C++中自带的，当然，C语言可以变量赋值交换 \n\t}\n\tswap(a[i],a[left]);//基准数归位 \n\tquicksort(left,i-1);//继续归位分界点左边的序列 \n\tquicksort(i+1,right);//继续归位分界点右边的序列 \n\t//实际上是一个递归和二分的过程 \n}\n```\n假如我们输入以下数据\n\n     \n     10 \n     6 1 2 7 9 3 4 5 10 8 \n   得到的结果就是\n   \t  \n   \t  1 2 3 4 5 6 7 8 9 10\n   下面就是这个序列变化的过程(带*号的是基准数)\n    \n     6 1 2 7 9 3 4 5 10 8 \n     3 1 2 5 4 *6* 9 7 10 8 \n     2 1 *3* 5 4 6 9 7 10 8 \n     1 *2* 3 5 4 6 9 7 10 8 \n     *1* 2 3 5 4 6 9 7 10 8 \n     1 2 3 4 *5* 6 9 7 10 8 \n     1 2 3 *4* 5 6 9 7 10 8 \n     1 2 3 4 5 6 8 7 *9* 10 \n     1 2 3 4 5 6 7 *8* 9 10 \n     1 2 3 4 5 6 *7* 8 9 10 \n     1 2 3 4 5 6 7 8 9 *10*\n文末附上完整代码\n\n```cpp\n#include<bits/stdc++.h>//万能头文件真香 \nusing namespace std;\nint a[505];//这里我们定义全局变量，函数中方可调用 \nint n;\nvoid quicksort(int left,int right)\n{\n\tif(left>right)\n\t\treturn ;//判断是否错误 \n\tint i=left,j=right; \n\tint temp=a[left];//temp 用来存储基准数 \n\twhile(i!=j)//当i,j没有相遇时 \n\t{\n\t\twhile(a[j]>=temp&&i<j)//直到寻找到一个比基准数大的数 \n\t\t\tj--;\n\t\twhile(a[i]<=temp&&i<j)//直到寻找到一个比基准数大的数\n\t\t\ti++;\n\t\tif(i<j)//必须满足i<j \n\t\t\tswap(a[i],a[j]);//swap是C++中自带的，当然，C语言可以变量赋值交换 \n\t}\n\tswap(a[i],a[left]);//基准数归位 \n\tquicksort(left,i-1);//继续归位分界点左边的序列 \n\tquicksort(i+1,right);//继续归位分界点右边的序列 \n\t//实际上是一个递归和二分的过程 \n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++)\n\t\tscanf(\"%d\",&a[i]);\n\tquicksort(1,n);//调用函数 \n\tfor(int i=1;i<=n;i++)\n\t\tprintf(\"%d \",a[i]);\n\treturn 0;\t\n} \n```\n\n\n\n\n\t\t\t\t\t\t\t\n\n\n\n\n   \n\n\t\n\n","categories":["C++"]},{"title":"Hello World","url":"/2022/01/20/hello-world/","content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n <!-- more -->\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n"}]