[{"title":"HENAU冬令营-递推专题","url":"/2022/02/06/dp题解/","content":"nb","tags":["C++"],"categories":["题解"]},{"title":"Tips 1","url":"/2022/01/26/tips/","content":"# 1.i++ 与 ++i 的区别\n在编写C++程序中，我们总会遇到各种各样的小问题，例如语法问题，格式问题等等让我们头疼的小错误\n\n接下来我会将我遇到的小问题逐步更新到该tips上面\n<!--more-->\n对于 i=1，i++ 和 ++i 的结果都是 2；\n他们都等效于i=i+1；\n而不同的是，i++是先进行操作，然后再加一，而对于++i，则是先将i的值加一，再进行操作\n接下来我们以一串代码为例：\n```cpp\nint i = 1;\nwhile ( i++ < 3 ) {\n    cout << \"MQZ\" << endl;\n}\ncout << i;\n```\n运行这段代码，我们将会得到以下结果：\n    \n   MQZ\n\n   MQZ\n\n   4\n\n当我们把i++替换成++i时：\n```cpp\nint i = 1;\nwhile ( ++i < 3 ) {\n    cout << \"MQZ\" << endl;\ncout << i;\n}\n```\n运行的结果则是：\n\n   MQZ\n    \n3\n\n对于第一种情况，先判断i是否小于3，再进行赋值操作，第一个循环出来i=2，第二个循环出来i=3，然后进入第三个循环的判断，此时，i已经不满足条件了，退出循环，但是注意，判断过后i++的操作还是要进行，所以最后i的值为4\n\n对于第二种情况，先进行i=i+1，再进行判断加一过后的i是否小于3，所以最后i=3；\n\n即i++先赋值后加1，++i先加1后赋值；\n例：\ncase1:\n    \n    i = 1 , y = i++;  等效于  i = 1 , y = i , i = i + 1 ; 结果为： i = 1 , y = 1;\ncase 2:\n\n    i = 1 , y = ++i;  等效于  i = 1 , i = i + 1 , y = i ; 结果为： i = 1 , y = 2;","categories":["tips"]},{"title":"常用算法之——贪心","url":"/2022/01/25/贪心/","content":"# 贪心算法\n贪心算法（又称贪婪算法）是指，在对问题求解时，总是做出在当前看来是最好的选择。也就是说，不从整体最优上加以考虑，算法得到的是在某种意义上的局部最优解。”\n\n<!--more-->\n### 解题的一般步骤：\n1.建立数学模型来描述问题\n2.把求解的问题分为若干个子问题\n3.对每一个子问题求解，得到子问题的局部最优解\n4.把子问题的局部最优解合成原来问题的解\n\n### 贪心算法的基本思想：\n   从问题的某一个初始解，逐步逼近给定的目标，直到某一步无法进行\n1. 无法保证最后求得的解是最佳的解\n2. 无法用来求最小解或最大解问题\n3. ","tags":["C++"],"categories":["基础算法"]},{"title":"快速排序","url":"/2022/01/21/newpapername/","content":"## 快速排序\n\n## 1.举个例子\n   首先我们给出组数据：6 1 2 7 9 3 4 5 10 8\n   接下来，我们的目的是将他们**从小到大**排序；\n   \n   首先：我们设立一个**基准数**(也就是这组数据的第一个数，6)，接下来，我们需要把**比基准数6大**的数全部放到6的**右边**，**比基准数6小**的数全部放到6的**左边**（也就是将**基准数**放在中间某个位置使得基准数左边的数全部小于他，基准数右边的数全部大于他）\n   \n   那么我们该如何实现这个过程呢？\n   我们可以用**交换**的方法，我们从右边开始，寻找一个**比6小**的数，再从左边寻找一个**比6大**的数，然后**交换他们的位置**\n   这里我们需要用到两个小可爱：**i** 和 **j**；让他们分别从左右两端开始寻找符合要求的数\n   看下图\n\n|   ==6==   |   1   |   2   |   7   |   9   |   3   |   4   |   5   |   10   |   ==8==   |\n|:----:|----|----|----|----|----|----|----|----|:----:|\n|   ==**i**==  |      |      |      |      |      |    |      |    |   ==**j**==  |\n\n小可爱 **j** 开始移动（每次必须是从 j 开始！）\n\n|  ==6==   |   1   |   2   |   7   |   9   |   3   |   4   |  ==5==   |   10   |   8   |\n|:----:|----|----|----|----|----|----|:----:|----|----|\n|   ==**i**==  |      |      |      |      |      |    |    ==**j**==   |    |    |\n\n找到一个比6小的数了，然后就是 i 的工作了\n\n|   6   |   1   |   2   |  ==7==   |   9   |   3   |   4   |   ==5==   |   10   |   8   |\n|----|----|----|:----:|----|----|----|:----:|----|----|\n|     |      |      | ==**i**==    |      |      |    |    ==**j**==   |    |    |\n\n交换！\n\n|   6   |   1   |   2   |  ==5==   |   9   |   3   |   4   |   ==7==   |   10   |   8   |\n|----|----|----|:----:|----|----|----|:----:|----|----|\n|     |      |      | ==**i**==    |      |      |    |    ==**j**==   |    |    |\n\n我们发现 **i** 和 **j** 并没有相遇，那么我们继续，我们发现9>6,4<6,果断交换！\n\n|   6   |   1   |   2   |  5   |   ==4==   |   3   |   ==9==   |   7 |   10   |   8   |\n|----|----|----|----|:----:|----|:----:|----|----|----|\n|     |      |      |    | ==**i**==      |      |    ==**j**==  |     |    |    |\n\n接下来，我们的小可爱 **i** 和 **j** 终于见到了彼此，那么我们就将 3 和 **基准数6** 交换，这样我们就找到了属于 6 的那个专属位置 **k** ！\n\n|   ==3==   |   1   |   2   |  5   |   4   |   ==6==   |   9  |   7 |   10   |   8   |\n|----|----|----|----|----|:----:|----|----|----|----|\n|     |      |      |    |   |   ==**i j**==    |      |     |    |    |\n\n到此第一轮“探测”真正结束。现在**基准数6**已经归位，此时以**基准数6**为分界点，6左边的数都小于等于6，6右边的数都大于等于6。回顾一下刚才的过程，其实哨兵 **j** 的使命就是要找小于基准数的数，而哨兵 **i** 的使命就是要找大于基准数的数，直到 **i** 和 **j** 碰头为止。\n\n现在我们将第一轮“探测\"结束后的序列，就需要用到**二分**的思想。以6为**分界点**拆分成两个序列，左边的序列是“3 1 2 5 4”，右边的序列是“9 7 10 8”。接下来还需要分别处理这两个序列。因为6左边和右边的序列目前都还是很混乱的。不过不要紧，我们已经掌握了方法，接下来只要模拟刚才的方法分别处理6左边和右边的序列即可。现在先来处理6左边的序列现吧。\n\n第一轮探测后，我们得到以下序列\n\n|   ==2==   |   1   |   ==3==   |  5   |   4   |\n|----|----|----|----|----|\n\n接下来我们又以 3 为分界点\n\n|   ==1==   |   ==2==   |   3   |  ==4==   |  ==5==   |\n|----|----|----|----|----|\n\n如此便将 6 左边的序列排好序，右边同样如此；\n由此我们可以发现，每一轮排序的过程，就是将**基准数**归位的过程，直到将每一位**基准数**归位，这个过程就结束了。\n\n接下来以《啊哈算法》里面的图示来展现：\n![666](https://img-blog.csdnimg.cn/c8d7255438c8415cb3828253eb1b0ce5.jpg?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5qmY6JC95Lqs5Z-O,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center)\n在最坏的情况下，可能是相邻的两个数进行了交换。因此快速排序的最差时间复杂度和\n冒泡排序是一样的，都是 O(N2)，它的平均时间复杂度为 O (NlogN)。其实快速排序是基于一种叫做“二分”的思想。\n## 2.代码实现\n下面是这个算法的代码实现\n\n```cpp\nvoid quicksort(int left,int right)\n{\n\tif(left>right)\n\t\treturn ;//判断是否错误 \n\tint i=left,j=right; \n\tint temp=a[left];//temp 用来存储基准数 \n\twhile(i!=j)//当i,j没有相遇时 \n\t{\n\t\twhile(a[j]>=temp&&i<j)//直到寻找到一个比基准数大的数 \n\t\t\tj--;\n\t\twhile(a[i]<=temp&&i<j)//直到寻找到一个比基准数大的数\n\t\t\ti++;\n\t\tif(i<j)//必须满足i<j \n\t\t\tswap(a[i],a[j]);//swap是C++中自带的，当然，C语言可以变量赋值交换 \n\t}\n\tswap(a[i],a[left]);//基准数归位 \n\tquicksort(left,i-1);//继续归位分界点左边的序列 \n\tquicksort(i+1,right);//继续归位分界点右边的序列 \n\t//实际上是一个递归和二分的过程 \n}\n```\n假如我们输入以下数据\n\n     \n     10 \n     6 1 2 7 9 3 4 5 10 8 \n   得到的结果就是\n   \t  \n   \t  1 2 3 4 5 6 7 8 9 10\n   下面就是这个序列变化的过程(带*号的是基准数)\n    \n     6 1 2 7 9 3 4 5 10 8 \n     3 1 2 5 4 *6* 9 7 10 8 \n     2 1 *3* 5 4 6 9 7 10 8 \n     1 *2* 3 5 4 6 9 7 10 8 \n     *1* 2 3 5 4 6 9 7 10 8 \n     1 2 3 4 *5* 6 9 7 10 8 \n     1 2 3 *4* 5 6 9 7 10 8 \n     1 2 3 4 5 6 8 7 *9* 10 \n     1 2 3 4 5 6 7 *8* 9 10 \n     1 2 3 4 5 6 *7* 8 9 10 \n     1 2 3 4 5 6 7 8 9 *10*\n文末附上完整代码\n\n```cpp\n#include<bits/stdc++.h>//万能头文件真香 \nusing namespace std;\nint a[505];//这里我们定义全局变量，函数中方可调用 \nint n;\nvoid quicksort(int left,int right)\n{\n\tif(left>right)\n\t\treturn ;//判断是否错误 \n\tint i=left,j=right; \n\tint temp=a[left];//temp 用来存储基准数 \n\twhile(i!=j)//当i,j没有相遇时 \n\t{\n\t\twhile(a[j]>=temp&&i<j)//直到寻找到一个比基准数大的数 \n\t\t\tj--;\n\t\twhile(a[i]<=temp&&i<j)//直到寻找到一个比基准数大的数\n\t\t\ti++;\n\t\tif(i<j)//必须满足i<j \n\t\t\tswap(a[i],a[j]);//swap是C++中自带的，当然，C语言可以变量赋值交换 \n\t}\n\tswap(a[i],a[left]);//基准数归位 \n\tquicksort(left,i-1);//继续归位分界点左边的序列 \n\tquicksort(i+1,right);//继续归位分界点右边的序列 \n\t//实际上是一个递归和二分的过程 \n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++)\n\t\tscanf(\"%d\",&a[i]);\n\tquicksort(1,n);//调用函数 \n\tfor(int i=1;i<=n;i++)\n\t\tprintf(\"%d \",a[i]);\n\treturn 0;\t\n} \n```\n\n\n\n\n\t\t\t\t\t\t\t\n\n\n\n\n   \n\n\t\n\n","tags":["C++"],"categories":["基础算法"]},{"title":"Hello World","url":"/2022/01/20/hello-world/","content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n <!-- more -->\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n"}]